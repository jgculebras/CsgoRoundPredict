# -*- coding: utf-8 -*-
"""CsgoRoundPredict.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K9ec5TO21ocyqSmzbeQRD_zrlezpT8nV

# **Carga de Datos**

Puesto que se tratan de archivos de mas de 25MB, no se pueden subir al github desde el entorno web si no que hemos de hacer un clone del repositorio con git y hacer un push de nuestro repositorio local a github.
Una vez estan cargados los datos diferenciaremos 4 variables, *trainCsvWithTarget* y *target* las utilizaremos para el analisis de datos mientras que *trainCsv* y *testCsv* seran utilizadas en el procesamiento de estos.
"""

import pandas as pd

trainCsvWithTarget = pd.read_csv('https://raw.githubusercontent.com/jgculebras/CsgoRoundPredict/main/CsvFiles/train.csv')
testCsv = pd.read_csv('https://raw.githubusercontent.com/jgculebras/CsgoRoundPredict/main/CsvFiles/test.csv')


target = trainCsvWithTarget['round_winner']
trainCsv = trainCsvWithTarget.drop(['round_winner', 'round_winner.1'], axis = 1)

"""# **Analisis de Datos**

Desplegamos algunas graficas que nos ayudaran a entender mejor el problema y con los datos que estamos trabajando, en ellas podemos ver:
- Una comparativa de las rondas ganadas por cada bando en caso de que se plante la bomba o no.
- Las rondas ganadas de cada bando en funcion del mapa elegido.
- Una comparativa estimada de las rondas ganadas por cada bando en funcion de los kits que haya en el equipo CT.
- Las rondas ganadas por cada bando en este conjunto de datos.
- Por ultimo echamos un vistazo a la grafica 'time_left' que nos parecia extraña ya que contenia muchos valores que no encuadraban con el problema. (Esta está analizada en al final del cuaderno)
"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8,6))
ax = sns.countplot(x="bomb_planted", hue="round_winner", data=trainCsvWithTarget)
ax.set(title='Round winners when bomb planted/not planted')
plt.show()

plt.figure(figsize=(8,6))
ax = sns.countplot(x="map", hue="round_winner", data=trainCsvWithTarget)
ax.set(title='Round winners for various maps')
plt.show()

plt.figure(figsize=(8,6))
ax = sns.countplot(x="ct_defuse_kits", hue="round_winner", data=trainCsvWithTarget)
ax.set(title='Round winners when ct have x kits')
plt.show()

plt.figure(figsize=(8,6))
ax = sns.displot(x="round_winner", data=trainCsvWithTarget)
ax.set(title='CT/T Round Wins')
plt.show()

plt.figure(figsize=(8,6))
ax = sns.displot(x="time_left", data=trainCsv)
ax.set(title='Time left for round')
plt.show()

"""Por ultimo respecto al analisis de datos, queriamos observar un porcentaje estimado de victorias entre cada bando, puesto que el conjunto de datos contiene rondas que no estan del todo equilibradas, realizamos una consulta en donde igualamos la vida de cada bando a la correspondiente de inicio de ronda para generalizar mas el resultado."""

array = []
for index, row in trainCsvWithTarget.iterrows():
  if (row['ct_health'] == 500 and row['t_health'] == 500):
    array.append(row['round_winner'])

"""Como vemos, el bando CT gana mas rondas que el equipo T, algo que se ajusta mas a la realidad."""

import numpy as np

(unique, counts) = np.unique(array, return_counts=True)

frequencies = np.asarray((unique, counts)).T

print(frequencies)

"""# **Preprocesamiento de Datos**

**Calculo valor equipamiento Ronda**

Creemos conveniente realizar una conversion de las armas/equipamiento que lleva cada bando en cada ronda a su valor en el juego, para ello exploramos cada fila del dataset y las columnas que nos indican las armas/granadas de cada bando multiplicando estas por su correspondiente valor, extraido de *https://counterstrike.fandom.com/wiki/Buy_menu*
"""

ctWeaponValueArray = []
ctWeaponValue = 0

ct2ndWeaponValueArray = []
ct2ndWeaponValue = 0


tWeaponValueArray = []
tWeaponValue = 0

t2ndWeaponValueArray = []
t2ndWeaponValue = 0

ctGranadeValueArray = []
ctGranadeValue = 0


tGranadeValueArray = []
tGranadeValue = 0



for index, row in trainCsv.iterrows():
  ctWeaponValue += row['ct_weapon_ak47'] * 2700
  tWeaponValue += row['t_weapon_ak47'] * 2700
  ctWeaponValue += row['ct_weapon_aug'] * 3300
  tWeaponValue += row['t_weapon_aug'] * 3300
  ctWeaponValue += row['ct_weapon_awp'] * 4750
  tWeaponValue += row['t_weapon_awp'] * 4750
  ctWeaponValue += row['ct_weapon_bizon'] * 1400
  tWeaponValue += row['t_weapon_bizon'] * 1400
  ctWeaponValue += row['ct_weapon_famas'] * 2050
  tWeaponValue += row['t_weapon_famas'] * 2050
  ctWeaponValue += row['ct_weapon_g3sg1'] * 5000
  tWeaponValue += row['t_weapon_g3sg1'] * 5000
  ctWeaponValue += row['ct_weapon_galilar'] * 1800
  tWeaponValue += row['t_weapon_galilar'] * 1800
  ctWeaponValue += row['ct_weapon_m249'] * 5200
  tWeaponValue += row['t_weapon_m249'] * 5200
  ctWeaponValue += row['ct_weapon_m4a1s'] * 2900
  tWeaponValue += row['t_weapon_m4a1s'] * 2900
  ctWeaponValue += row['ct_weapon_m4a4'] * 3100
  tWeaponValue += row['t_weapon_m4a4'] * 3100
  ctWeaponValue += row['ct_weapon_mac10'] * 1050
  tWeaponValue += row['t_weapon_mac10'] * 1050
  ctWeaponValue += row['ct_weapon_mag7'] * 1300
  tWeaponValue += row['t_weapon_mag7'] * 1300
  ctWeaponValue += row['ct_weapon_mp5sd'] * 1500
  tWeaponValue += row['t_weapon_mp5sd'] * 1500
  ctWeaponValue += row['ct_weapon_mp7'] * 1500
  tWeaponValue += row['t_weapon_mp7'] * 1500
  ctWeaponValue += row['ct_weapon_mp9'] * 1250
  tWeaponValue += row['t_weapon_mp9'] * 1250
  ctWeaponValue += row['ct_weapon_negev'] * 1700
  tWeaponValue += row['t_weapon_negev'] * 1700
  ctWeaponValue += row['ct_weapon_nova'] * 1050
  tWeaponValue += row['t_weapon_nova'] * 1050
  ctWeaponValue += row['ct_weapon_p90'] * 2350
  tWeaponValue += row['t_weapon_p90'] * 2350
  ctWeaponValue += row['ct_weapon_sawedoff'] * 1100
  tWeaponValue += row['t_weapon_sawedoff'] * 1100
  ctWeaponValue += row['ct_weapon_scar20'] * 5000
  tWeaponValue += row['t_weapon_scar20'] * 5000
  ctWeaponValue += row['ct_weapon_sg553'] * 3000
  tWeaponValue += row['t_weapon_sg553'] * 3000
  ctWeaponValue += row['ct_weapon_ssg08'] * 1700
  tWeaponValue += row['t_weapon_ssg08'] * 1700
  ctWeaponValue += row['ct_weapon_ump45'] * 1200
  tWeaponValue += row['t_weapon_ump45'] * 1200
  ctWeaponValue += row['ct_weapon_xm1014'] * 2000
  tWeaponValue += row['t_weapon_xm1014'] * 2000

  ct2ndWeaponValue += row['ct_weapon_cz75auto'] * 500
  t2ndWeaponValue += row['t_weapon_cz75auto'] * 500
  ct2ndWeaponValue += row['ct_weapon_elite'] * 400
  t2ndWeaponValue += row['t_weapon_elite'] * 400
  ct2ndWeaponValue += row['ct_weapon_glock'] * 200
  t2ndWeaponValue += row['t_weapon_glock'] * 200
  ct2ndWeaponValue += row['ct_weapon_r8revolver'] * 600
  t2ndWeaponValue += row['t_weapon_r8revolver'] * 600
  ct2ndWeaponValue += row['ct_weapon_deagle'] * 700
  t2ndWeaponValue += row['t_weapon_deagle'] * 700
  ct2ndWeaponValue += row['ct_weapon_fiveseven'] * 500
  t2ndWeaponValue += row['t_weapon_fiveseven'] * 500
  ct2ndWeaponValue += row['ct_weapon_usps'] * 200
  t2ndWeaponValue += row['t_weapon_usps'] * 200
  ct2ndWeaponValue += row['ct_weapon_p250'] * 300
  t2ndWeaponValue += row['t_weapon_p250'] * 300
  ct2ndWeaponValue += row['ct_weapon_p2000'] * 200
  t2ndWeaponValue += row['t_weapon_p2000'] * 200
  ct2ndWeaponValue += row['ct_weapon_tec9'] * 500
  t2ndWeaponValue += row['t_weapon_tec9'] * 500

  ctGranadeValue += row['ct_grenade_hegrenade'] * 300
  tGranadeValue += row['t_grenade_hegrenade'] * 300
  ctGranadeValue += row['ct_grenade_flashbang'] * 200
  tGranadeValue += row['t_grenade_flashbang'] * 200
  ctGranadeValue += row['ct_grenade_smokegrenade'] * 300
  tGranadeValue += row['t_grenade_smokegrenade'] * 300
  ctGranadeValue += row['ct_grenade_incendiarygrenade'] * 600
  tGranadeValue += row['t_grenade_incendiarygrenade'] * 600
  ctGranadeValue += row['ct_grenade_molotovgrenade'] * 400
  tGranadeValue += row['t_grenade_molotovgrenade'] * 400
  ctGranadeValue += row['ct_grenade_decoygrenade'] * 50
  tGranadeValue += row['t_grenade_decoygrenade'] * 50


  ctWeaponValueArray.append(ctWeaponValue)
  tWeaponValueArray.append(tWeaponValue)

  ct2ndWeaponValueArray.append(ct2ndWeaponValue)
  t2ndWeaponValueArray.append(t2ndWeaponValue)

  ctGranadeValueArray.append(ctGranadeValue)
  tGranadeValueArray.append(tGranadeValue)

  tWeaponValue = 0
  ctWeaponValue = 0

  t2ndWeaponValue = 0
  ct2ndWeaponValue = 0

  ctGranadeValue = 0
  tGranadeValue = 0

"""Creamos un DataFrame con estos datos que utilizaremos mas tarde."""

eqValue = pd.DataFrame(list(zip(ctWeaponValueArray, tWeaponValueArray, ct2ndWeaponValueArray, t2ndWeaponValueArray, ctGranadeValueArray, tGranadeValueArray)), columns = ['ctWeaponValue', 'tWeaponValue', 'ct2ndWeaponValue', 't2ndWeaponValue', 'ctGrenadeValue', 'tGrenadeValue'])
eqValue

"""Puesto que ya nos hemos hecho la transformacion de armas a su valor en dinero, y no queremos añadir muchas sentencias drop de cada columna correspondiente a cada arma, guardamos como trainDfTransformed el DataFrame inicial pero sin las columnas de cada arma equipada. En la siguiente sentencia lo concatenamos con el DataFrame de la celda anterior obteniendo asi nuestro DataFrame completo.

Posteriormente utilizaremos LabelEncoder y OneHotEncoder para transformar las columnas 'map', 'bomb_planted' y el target ('round_winner')
"""

from sklearn.preprocessing import OneHotEncoder, LabelEncoder

trainDfTransformed = trainCsv[['ct_score' , 't_score' , 'time_left', 'map' , 'bomb_planted' , 'ct_health' , 't_health' , 'ct_armor' , 't_armor' , 'ct_money', 't_money' , 'ct_helmets' , 't_helmets' , 'ct_defuse_kits' , 'ct_players_alive' , 't_players_alive']]
trainDfTransformed = pd.concat([trainDfTransformed, eqValue], axis = 1)

trainDfTransformed['map'] = LabelEncoder().fit_transform(trainDfTransformed['map'])

bombPlantedDf = pd.DataFrame(OneHotEncoder().fit_transform(trainDfTransformed[['bomb_planted']]).toarray(), columns = ['no_bomb_planted', 'yes_bomb_planted'])

trainDfTransformed = pd.concat((trainDfTransformed , bombPlantedDf) , axis = 1)

trainDfTransformed = trainDfTransformed.drop(['bomb_planted'], axis = 1)

target = pd.DataFrame(LabelEncoder().fit_transform(target), columns = ['Round_Winner'])
trainDfTransformed

"""# **Eleccion del modelo**

**Logistic Regression**
"""

from sklearn.model_selection import train_test_split
from sklearn.svm import LinearSVC

X_train, X_test, Y_train, Y_test = train_test_split(trainDfTransformed, target, test_size = 0.2)
from sklearn.linear_model import LogisticRegression

lgr = LogisticRegression(random_state=0).fit(X_train, Y_train)

from sklearn.metrics import classification_report

y_pred = lgr.predict(X_test)

print(classification_report(Y_test, y_pred))

"""**K-Nearest-Neighbors**"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(trainDfTransformed, target, test_size = 0.2)

knn = KNeighborsClassifier(n_neighbors=4).fit(X_train, Y_train)

from sklearn.metrics import classification_report

y_pred = knn.predict(X_test)

print(classification_report(Y_test, y_pred))

"""**Arbol de decision**"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(trainDfTransformed, target, test_size = 0.2)

dtc = DecisionTreeClassifier(criterion='entropy', splitter='random', max_depth=5, random_state=43)
dtc = dtc.fit(X_train,Y_train)

from sklearn.metrics import classification_report

y_pred = dtc.predict(X_test)

print(classification_report(Y_test, y_pred))

"""**Gradient Boost Classifier**"""

from sklearn.ensemble import GradientBoostingClassifier
from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(trainDfTransformed, target, test_size = 0.2)

clf = GradientBoostingClassifier(n_estimators=350, learning_rate=1.0, max_depth=12, random_state=0).fit(X_train, Y_train)

from sklearn.metrics import classification_report

y_pred = clf.predict(X_test)

print(classification_report(Y_test, y_pred))

"""Como podemos ver, el modelo que mejor nos funciona de los casos probados es el Gradient Boosting Classifier, un algoritmo que usa Arboles de Regresion. Los hiperparametros utilizados son para los estimadores 350 y para la profundidad 12, puesto que vimos que a mayor/menor numero de estimadores mas impreciso era y respecto a la profundidad, a mayor profundidad obteniamos mas Overfitting y a menor profundidad era mas impreciso.

# **Prediccion del testCsv**

Como hemos hecho con el trainCsv y para entrenar al modelo, transformamos los datos necesarios para que se ajusten al modelo, y hacemos un predict con el modelo elejido en nuestro caso Gradient Boosting Classifier, en las siguientes sentencias simplemente transformamos los valores binarios a las correspondientes etiquetas ('CT'/'T') como se nos pide en el enunciado y exportamos a Csv con la libreria de pandas.
"""

ctWeaponValueArray = []
ctWeaponValue = 0

ct2ndWeaponValueArray = []
ct2ndWeaponValue = 0


tWeaponValueArray = []
tWeaponValue = 0

t2ndWeaponValueArray = []
t2ndWeaponValue = 0

ctGranadeValueArray = []
ctGranadeValue = 0


tGranadeValueArray = []
tGranadeValue = 0



for index, row in testCsv.iterrows():
  ctWeaponValue += row['ct_weapon_ak47'] * 2700
  tWeaponValue += row['t_weapon_ak47'] * 2700
  ctWeaponValue += row['ct_weapon_aug'] * 3300
  tWeaponValue += row['t_weapon_aug'] * 3300
  ctWeaponValue += row['ct_weapon_awp'] * 4750
  tWeaponValue += row['t_weapon_awp'] * 4750
  ctWeaponValue += row['ct_weapon_bizon'] * 1400
  tWeaponValue += row['t_weapon_bizon'] * 1400
  ctWeaponValue += row['ct_weapon_famas'] * 2050
  tWeaponValue += row['t_weapon_famas'] * 2050
  ctWeaponValue += row['ct_weapon_g3sg1'] * 5000
  tWeaponValue += row['t_weapon_g3sg1'] * 5000
  ctWeaponValue += row['ct_weapon_galilar'] * 1800
  tWeaponValue += row['t_weapon_galilar'] * 1800
  ctWeaponValue += row['ct_weapon_m249'] * 5200
  tWeaponValue += row['t_weapon_m249'] * 5200
  ctWeaponValue += row['ct_weapon_m4a1s'] * 2900
  tWeaponValue += row['t_weapon_m4a1s'] * 2900
  ctWeaponValue += row['ct_weapon_m4a4'] * 3100
  tWeaponValue += row['t_weapon_m4a4'] * 3100
  ctWeaponValue += row['ct_weapon_mac10'] * 1050
  tWeaponValue += row['t_weapon_mac10'] * 1050
  ctWeaponValue += row['ct_weapon_mag7'] * 1300
  tWeaponValue += row['t_weapon_mag7'] * 1300
  ctWeaponValue += row['ct_weapon_mp5sd'] * 1500
  tWeaponValue += row['t_weapon_mp5sd'] * 1500
  ctWeaponValue += row['ct_weapon_mp7'] * 1500
  tWeaponValue += row['t_weapon_mp7'] * 1500
  ctWeaponValue += row['ct_weapon_mp9'] * 1250
  tWeaponValue += row['t_weapon_mp9'] * 1250
  ctWeaponValue += row['ct_weapon_negev'] * 1700
  tWeaponValue += row['t_weapon_negev'] * 1700
  ctWeaponValue += row['ct_weapon_nova'] * 1050
  tWeaponValue += row['t_weapon_nova'] * 1050
  ctWeaponValue += row['ct_weapon_p90'] * 2350
  tWeaponValue += row['t_weapon_p90'] * 2350
  ctWeaponValue += row['ct_weapon_sawedoff'] * 1100
  tWeaponValue += row['t_weapon_sawedoff'] * 1100
  ctWeaponValue += row['ct_weapon_scar20'] * 5000
  tWeaponValue += row['t_weapon_scar20'] * 5000
  ctWeaponValue += row['ct_weapon_sg553'] * 3000
  tWeaponValue += row['t_weapon_sg553'] * 3000
  ctWeaponValue += row['ct_weapon_ssg08'] * 1700
  tWeaponValue += row['t_weapon_ssg08'] * 1700
  ctWeaponValue += row['ct_weapon_ump45'] * 1200
  tWeaponValue += row['t_weapon_ump45'] * 1200
  ctWeaponValue += row['ct_weapon_xm1014'] * 2000
  tWeaponValue += row['t_weapon_xm1014'] * 2000

  ct2ndWeaponValue += row['ct_weapon_cz75auto'] * 500
  t2ndWeaponValue += row['t_weapon_cz75auto'] * 500
  ct2ndWeaponValue += row['ct_weapon_elite'] * 400
  t2ndWeaponValue += row['t_weapon_elite'] * 400
  ct2ndWeaponValue += row['ct_weapon_glock'] * 200
  t2ndWeaponValue += row['t_weapon_glock'] * 200
  ct2ndWeaponValue += row['ct_weapon_r8revolver'] * 600
  t2ndWeaponValue += row['t_weapon_r8revolver'] * 600
  ct2ndWeaponValue += row['ct_weapon_deagle'] * 700
  t2ndWeaponValue += row['t_weapon_deagle'] * 700
  ct2ndWeaponValue += row['ct_weapon_fiveseven'] * 500
  t2ndWeaponValue += row['t_weapon_fiveseven'] * 500
  ct2ndWeaponValue += row['ct_weapon_usps'] * 200
  t2ndWeaponValue += row['t_weapon_usps'] * 200
  ct2ndWeaponValue += row['ct_weapon_p250'] * 300
  t2ndWeaponValue += row['t_weapon_p250'] * 300
  ct2ndWeaponValue += row['ct_weapon_p2000'] * 200
  t2ndWeaponValue += row['t_weapon_p2000'] * 200
  ct2ndWeaponValue += row['ct_weapon_tec9'] * 500
  t2ndWeaponValue += row['t_weapon_tec9'] * 500

  ctGranadeValue += row['ct_grenade_hegrenade'] * 300
  tGranadeValue += row['t_grenade_hegrenade'] * 300
  ctGranadeValue += row['ct_grenade_flashbang'] * 200
  tGranadeValue += row['t_grenade_flashbang'] * 200
  ctGranadeValue += row['ct_grenade_smokegrenade'] * 300
  tGranadeValue += row['t_grenade_smokegrenade'] * 300
  ctGranadeValue += row['ct_grenade_incendiarygrenade'] * 600
  tGranadeValue += row['t_grenade_incendiarygrenade'] * 600
  ctGranadeValue += row['ct_grenade_molotovgrenade'] * 400
  tGranadeValue += row['t_grenade_molotovgrenade'] * 400
  ctGranadeValue += row['ct_grenade_decoygrenade'] * 50
  tGranadeValue += row['t_grenade_decoygrenade'] * 50


  ctWeaponValueArray.append(ctWeaponValue)
  tWeaponValueArray.append(tWeaponValue)

  ct2ndWeaponValueArray.append(ct2ndWeaponValue)
  t2ndWeaponValueArray.append(t2ndWeaponValue)

  ctGranadeValueArray.append(ctGranadeValue)
  tGranadeValueArray.append(tGranadeValue)

  tWeaponValue = 0
  ctWeaponValue = 0

  t2ndWeaponValue = 0
  ct2ndWeaponValue = 0

  ctGranadeValue = 0
  tGranadeValue = 0

eqValue = pd.DataFrame(list(zip(ctWeaponValueArray, tWeaponValueArray, ct2ndWeaponValueArray, t2ndWeaponValueArray, ctGranadeValueArray, tGranadeValueArray)), columns = ['ctWeaponValue', 'tWeaponValue', 'ct2ndWeaponValue', 't2ndWeaponValue', 'ctGrenadeValue', 'tGrenadeValue'])
eqValue

from sklearn.preprocessing import OneHotEncoder, LabelEncoder

XDfTransformed = testCsv[['ct_score' , 't_score' , 'time_left', 'map' , 'bomb_planted' , 'ct_health' , 't_health' , 'ct_armor' , 't_armor' , 'ct_money', 't_money' , 'ct_helmets' , 't_helmets' , 'ct_defuse_kits' , 'ct_players_alive' , 't_players_alive']]
XDfTransformed = pd.concat([XDfTransformed, eqValue], axis = 1)

XDfTransformed['map'] = LabelEncoder().fit_transform(XDfTransformed['map'])

bombPlantedDf = pd.DataFrame(OneHotEncoder().fit_transform(XDfTransformed[['bomb_planted']]).toarray(), columns = ['no_bomb_planted', 'yes_bomb_planted'])

XDfTransformed = pd.concat((XDfTransformed , bombPlantedDf) , axis = 1)

XDfTransformed = XDfTransformed.drop(['bomb_planted'], axis = 1)

from sklearn.metrics import classification_report

pred = clf.predict(XDfTransformed)

df = pd.DataFrame(pred, columns = ['Round_Winner'])
df.loc[df.Round_Winner == 0, 'Round_Winner'] = 'CT'
df.loc[df.Round_Winner == 1, 'Round_Winner'] = 'T'

df = pd.concat((testCsv['id'], df), axis = 1)

df.to_csv('RoundWinner.csv', index = False, header = ["id", "Round_Winner"], sep = ',')

"""# **Observacion de la variable 'Time_Left'**

*En caso de que ya se hayan procesado los datos no es necesario ejecutar esta celda.*
"""

ctWeaponValueArray = []
ctWeaponValue = 0

ct2ndWeaponValueArray = []
ct2ndWeaponValue = 0


tWeaponValueArray = []
tWeaponValue = 0

t2ndWeaponValueArray = []
t2ndWeaponValue = 0

ctGranadeValueArray = []
ctGranadeValue = 0


tGranadeValueArray = []
tGranadeValue = 0



for index, row in trainCsv.iterrows():
  ctWeaponValue += row['ct_weapon_ak47'] * 2700
  tWeaponValue += row['t_weapon_ak47'] * 2700
  ctWeaponValue += row['ct_weapon_aug'] * 3300
  tWeaponValue += row['t_weapon_aug'] * 3300
  ctWeaponValue += row['ct_weapon_awp'] * 4750
  tWeaponValue += row['t_weapon_awp'] * 4750
  ctWeaponValue += row['ct_weapon_bizon'] * 1400
  tWeaponValue += row['t_weapon_bizon'] * 1400
  ctWeaponValue += row['ct_weapon_famas'] * 2050
  tWeaponValue += row['t_weapon_famas'] * 2050
  ctWeaponValue += row['ct_weapon_g3sg1'] * 5000
  tWeaponValue += row['t_weapon_g3sg1'] * 5000
  ctWeaponValue += row['ct_weapon_galilar'] * 1800
  tWeaponValue += row['t_weapon_galilar'] * 1800
  ctWeaponValue += row['ct_weapon_m249'] * 5200
  tWeaponValue += row['t_weapon_m249'] * 5200
  ctWeaponValue += row['ct_weapon_m4a1s'] * 2900
  tWeaponValue += row['t_weapon_m4a1s'] * 2900
  ctWeaponValue += row['ct_weapon_m4a4'] * 3100
  tWeaponValue += row['t_weapon_m4a4'] * 3100
  ctWeaponValue += row['ct_weapon_mac10'] * 1050
  tWeaponValue += row['t_weapon_mac10'] * 1050
  ctWeaponValue += row['ct_weapon_mag7'] * 1300
  tWeaponValue += row['t_weapon_mag7'] * 1300
  ctWeaponValue += row['ct_weapon_mp5sd'] * 1500
  tWeaponValue += row['t_weapon_mp5sd'] * 1500
  ctWeaponValue += row['ct_weapon_mp7'] * 1500
  tWeaponValue += row['t_weapon_mp7'] * 1500
  ctWeaponValue += row['ct_weapon_mp9'] * 1250
  tWeaponValue += row['t_weapon_mp9'] * 1250
  ctWeaponValue += row['ct_weapon_negev'] * 1700
  tWeaponValue += row['t_weapon_negev'] * 1700
  ctWeaponValue += row['ct_weapon_nova'] * 1050
  tWeaponValue += row['t_weapon_nova'] * 1050
  ctWeaponValue += row['ct_weapon_p90'] * 2350
  tWeaponValue += row['t_weapon_p90'] * 2350
  ctWeaponValue += row['ct_weapon_sawedoff'] * 1100
  tWeaponValue += row['t_weapon_sawedoff'] * 1100
  ctWeaponValue += row['ct_weapon_scar20'] * 5000
  tWeaponValue += row['t_weapon_scar20'] * 5000
  ctWeaponValue += row['ct_weapon_sg553'] * 3000
  tWeaponValue += row['t_weapon_sg553'] * 3000
  ctWeaponValue += row['ct_weapon_ssg08'] * 1700
  tWeaponValue += row['t_weapon_ssg08'] * 1700
  ctWeaponValue += row['ct_weapon_ump45'] * 1200
  tWeaponValue += row['t_weapon_ump45'] * 1200
  ctWeaponValue += row['ct_weapon_xm1014'] * 2000
  tWeaponValue += row['t_weapon_xm1014'] * 2000

  ct2ndWeaponValue += row['ct_weapon_cz75auto'] * 500
  t2ndWeaponValue += row['t_weapon_cz75auto'] * 500
  ct2ndWeaponValue += row['ct_weapon_elite'] * 400
  t2ndWeaponValue += row['t_weapon_elite'] * 400
  ct2ndWeaponValue += row['ct_weapon_glock'] * 200
  t2ndWeaponValue += row['t_weapon_glock'] * 200
  ct2ndWeaponValue += row['ct_weapon_r8revolver'] * 600
  t2ndWeaponValue += row['t_weapon_r8revolver'] * 600
  ct2ndWeaponValue += row['ct_weapon_deagle'] * 700
  t2ndWeaponValue += row['t_weapon_deagle'] * 700
  ct2ndWeaponValue += row['ct_weapon_fiveseven'] * 500
  t2ndWeaponValue += row['t_weapon_fiveseven'] * 500
  ct2ndWeaponValue += row['ct_weapon_usps'] * 200
  t2ndWeaponValue += row['t_weapon_usps'] * 200
  ct2ndWeaponValue += row['ct_weapon_p250'] * 300
  t2ndWeaponValue += row['t_weapon_p250'] * 300
  ct2ndWeaponValue += row['ct_weapon_p2000'] * 200
  t2ndWeaponValue += row['t_weapon_p2000'] * 200
  ct2ndWeaponValue += row['ct_weapon_tec9'] * 500
  t2ndWeaponValue += row['t_weapon_tec9'] * 500

  ctGranadeValue += row['ct_grenade_hegrenade'] * 300
  tGranadeValue += row['t_grenade_hegrenade'] * 300
  ctGranadeValue += row['ct_grenade_flashbang'] * 200
  tGranadeValue += row['t_grenade_flashbang'] * 200
  ctGranadeValue += row['ct_grenade_smokegrenade'] * 300
  tGranadeValue += row['t_grenade_smokegrenade'] * 300
  ctGranadeValue += row['ct_grenade_incendiarygrenade'] * 600
  tGranadeValue += row['t_grenade_incendiarygrenade'] * 600
  ctGranadeValue += row['ct_grenade_molotovgrenade'] * 400
  tGranadeValue += row['t_grenade_molotovgrenade'] * 400
  ctGranadeValue += row['ct_grenade_decoygrenade'] * 50
  tGranadeValue += row['t_grenade_decoygrenade'] * 50


  ctWeaponValueArray.append(ctWeaponValue)
  tWeaponValueArray.append(tWeaponValue)

  ct2ndWeaponValueArray.append(ct2ndWeaponValue)
  t2ndWeaponValueArray.append(t2ndWeaponValue)

  ctGranadeValueArray.append(ctGranadeValue)
  tGranadeValueArray.append(tGranadeValue)

  tWeaponValue = 0
  ctWeaponValue = 0

  t2ndWeaponValue = 0
  ct2ndWeaponValue = 0

  ctGranadeValue = 0
  tGranadeValue = 0

eqValue = pd.DataFrame(list(zip(ctWeaponValueArray, tWeaponValueArray, ct2ndWeaponValueArray, t2ndWeaponValueArray, ctGranadeValueArray, tGranadeValueArray)), columns = ['ctWeaponValue', 'tWeaponValue', 'ct2ndWeaponValue', 't2ndWeaponValue', 'ctGrenadeValue', 'tGrenadeValue'])

from sklearn.preprocessing import OneHotEncoder, LabelEncoder

trainDfTransformed = trainCsv[['ct_score' , 't_score' , 'time_left', 'map' , 'bomb_planted' , 'ct_health' , 't_health' , 'ct_armor' , 't_armor' , 'ct_money', 't_money' , 'ct_helmets' , 't_helmets' , 'ct_defuse_kits' , 'ct_players_alive' , 't_players_alive']]
trainDfTransformed = pd.concat([trainDfTransformed, eqValue], axis = 1)

trainDfTransformed['map'] = LabelEncoder().fit_transform(trainDfTransformed['map'])

bombPlantedDf = pd.DataFrame(OneHotEncoder().fit_transform(trainDfTransformed[['bomb_planted']]).toarray(), columns = ['no_bomb_planted', 'yes_bomb_planted'])

trainDfTransformed = pd.concat((trainDfTransformed , bombPlantedDf) , axis = 1)

trainDfTransformed = trainDfTransformed.drop(['bomb_planted'], axis = 1)

"""Realizamos la consulta correspondiente con la cual filtramos el dataset con time_left > 140 que son los valores que no nos cuadraban y los guardamos en un DataFrame."""

querry = []

for index, row in trainDfTransformed.iterrows():
  if (row['time_left'] >= 140):
    querry.append(row)
pd.DataFrame(querry)

"""Observando las diferentes filas vemos que aunque haya rondas en las cuales uno de los bandos tenga suficiente dinero para comprar armas de mayor valor no lo hacen e incluso en algunas ni lo hacen. Es por ello por lo que creemos que los valores del tiempo de ronda mayor a 115 significan que aun no se ha realizado ninguna compra y los equipos estan decidiendo diferentes estrategias o incluso estan en algun tiempo tecnico. Estos datos nos pueden llegar a afectar a nuestra solucion haciendo que tenga que profundizar mas de lo que deberia hacerlo si estos no estuvieran."""